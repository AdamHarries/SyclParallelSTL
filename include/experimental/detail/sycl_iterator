/* Copyright (c) 2015, Codeplay Software Ltd.
 * All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */  
/* vim: set filetype=cpp foldmethod=indent: */
#ifndef __EXPERIMENTAL_PARALLEL_SYCL_ITERATOR___
#define __EXPERIMENTAL_PARALLEL_SYCL_ITERATOR___

#include <type_traits>
#include <typeinfo>
#include <memory>
#include <cstdlib>
#include <cstring>
#include <algorithm>

#include <SYCL/sycl.hpp>

namespace std {
namespace experimental {
namespace parallel {
namespace sycl {

template <typename T, cl::sycl::access::mode Mode>
using sycl_host_acc =
    cl::sycl::accessor<T, 1, Mode, cl::sycl::access::target::host_buffer>;
template <typename T> using sycl_buffer_1d = cl::sycl::buffer<T, 1>;

class SyclIterator {
protected:
  size_t pos_;

public:
  SyclIterator(size_t pos) : pos_(pos) {};

  inline size_t get_pos() const { return pos_; }

  inline void set_pos(size_t pos) { pos_ = pos; }
};

struct buffer_iterator_tag {};
struct host_accessor_iterator_tag {};

template <typename T, cl::sycl::access::mode Mode>
class HostAccessorIterator : public SyclIterator {
private:
  sycl_host_acc<T, Mode> h_;

public:
  typedef T m_type;
  typedef T value_type;
  typedef size_t difference_type;
  typedef T *pointer;
  typedef T &reference;
  typedef std::random_access_iterator_tag iterator_category;
  typedef host_accessor_iterator_tag sycl_iterator_category;

  HostAccessorIterator(sycl_host_acc<T, Mode> &h, size_t pos)
      : SyclIterator(pos), h_(h) {}

  template <typename U, int ModeU>
  HostAccessorIterator(const HostAccessorIterator<U, ModeU> &hI)
      : SyclIterator(hI.get_pos()), h_(hI.h_) {}

  const HostAccessorIterator<T, Mode>
  operator+(const HostAccessorIterator<T, Mode> &other) const {
    HostAccessorIterator<T, Mode> result(*this);
    result.pos_ += other.get_pos();
    return result;
  }

  difference_type operator-(const HostAccessorIterator<T, Mode> &other) const {
    return this->get_pos() == other.get_pos();
  }

  const HostAccessorIterator<T, Mode> operator+(const int &value) const {
    HostAccessorIterator<T, Mode> result(*this);
    result.pos_ += value;
    return result;
  }

  const HostAccessorIterator<T, Mode> operator-(const int &value) const {
    HostAccessorIterator<T, Mode> result(*this);
    result.pos_ -= value;
    return result;
  }

  // Prefix operator (Increment and return value)
  HostAccessorIterator<T, Mode> &operator++() {
    this->pos_++;
    return (*this);
  }

  // Postfix operator (Return value and increment)
  HostAccessorIterator<T, Mode> operator++(int i) {
    HostAccessorIterator<T, Mode> tmp(*this);
    this->pos_ += 1;
    return tmp;
  }

  reference operator*() const { return h_[this->get_pos()]; }

  pointer operator->() const { return &h_[this->get_pos()]; }
};

template <typename T> class BufferIterator : public SyclIterator {
private:
  sycl_buffer_1d<T> b_;

public:
  typedef T m_type;
  typedef T value_type;
  typedef size_t difference_type;
  typedef T *pointer;
  typedef T &reference;
  typedef buffer_iterator_tag iterator_category;
  typedef buffer_iterator_tag sycl_iterator_category;

  BufferIterator(sycl_buffer_1d<T> &h, size_t pos) : SyclIterator(pos), b_(h) {}

  template <typename U>
  BufferIterator(const BufferIterator<U> &hI)
      : SyclIterator(hI.get_pos()), b_(hI.h_) {}

  inline sycl_buffer_1d<T> get_buffer() const { return b_; }

  const BufferIterator<T> operator+(const BufferIterator<T> &other) const {
    BufferIterator<T> result(*this);
    result.pos_ += other.get_pos();
    return result;
  }

  difference_type operator-(const BufferIterator<T> &other) const {
    return this->get_pos() - other.get_pos();
  }

  const BufferIterator<T> operator+(const int &value) const {
    BufferIterator<T> result(*this);
    result.pos_ += value;
    return result;
  }

  const BufferIterator<T> operator-(const int &value) const {
    BufferIterator<T> result(*this);
    result.pos_ -= value;
    return result;
  }

  // Prefix operator (Increment and return value)
  BufferIterator<T> &operator++() {
    this->pos_++;
    return (*this);
  }

  // Postfix operator (Return value and increment)
  BufferIterator<T> operator++(int i) {
    BufferIterator<T> tmp(*this);
    this->pos_ += 1;
    return tmp;
  }

  reference operator*() = delete;

  pointer operator->() = delete;
};

template <typename Iterator1, typename Iterator2>
inline bool operator==(Iterator1 a, Iterator2 b) {
  return a.get_pos() == b.get_pos();
}

template <typename Iterator1, typename Iterator2>
inline bool operator!=(Iterator1 a, Iterator2 b) {
  return !(a == b);
}

template <typename T, cl::sycl::access::mode Mode>
HostAccessorIterator<T, Mode> begin(sycl_host_acc<T, Mode> &h) {
  return HostAccessorIterator<T, Mode>(h, 0);
}

template <typename T, cl::sycl::access::mode Mode>
HostAccessorIterator<T, Mode> end(sycl_host_acc<T, Mode> &h) {
  return HostAccessorIterator<T, Mode>(h, h.get_count());
}

template <typename T> BufferIterator<T> begin(sycl_buffer_1d<T> &h) {
  return BufferIterator<T>(h, 0);
}

template <typename T> BufferIterator<T> end(sycl_buffer_1d<T> &h) {
  return BufferIterator<T>(h, h.get_count());
}

} // namespace sycl
} // namespace parallel
} // namespace experimental
} // namespace std

#endif // __EXPERIMENTAL_PARALLEL_SYCL_ITERATOR___
